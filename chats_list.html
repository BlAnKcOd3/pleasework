<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Chats - De Anza</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body data-page="chats">
  <header class="header"><h1>Chats</h1></header>

  <div class="container chat-list">
    <!-- Chat items will be rendered here -->
  </div>

  <footer class="site-footer">
    <a href="index.html"><img src="https://i.ibb.co/wNYjZG9k/Image-11-21-25-at-2-05-PM.png" alt="logo"></a>
  </footer>

  <script src="firebase_config.js"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getFirestore,
      collection,
      query,
      where,
      orderBy,
      onSnapshot,
      doc,
      setDoc,
      serverTimestamp
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    const container = document.querySelector('.container.chat-list');
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    // Parse optional global firebase config, otherwise fall back to explicit config
    let firebaseConfig = {};
    try {
      const parsed = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
      if (parsed && Object.keys(parsed).length > 0) firebaseConfig = parsed;
    } catch (e) {
      console.warn('Could not parse global __firebase_config, falling back to explicit config');
    }
    if (!firebaseConfig || Object.keys(firebaseConfig).length === 0) {
      firebaseConfig = {
        apiKey: "AIzaSyBJJYUOM8EBEuT39DX2F_HtxgEbHDRH-Zc",
        authDomain: "deanzahacks11-21-2025.firebaseapp.com",
        projectId: "deanzahacks11-21-2025",
      };
    }

    const urlParams = new URLSearchParams(window.location.search);
    const initialRecipientUid = urlParams.get('recipientUid');
    const initialAutoMessage = urlParams.get('autoMessage');
    let initialRecipientConsumed = false;

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Ensure we attempt to sign in (anonymous) proactively so onAuthStateChanged fires quickly
    (async function trySignIn() {
      try {
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        if (initialAuthToken) {
          await signInWithCustomToken(auth, initialAuthToken);
        } else {
          await signInAnonymously(auth);
        }
      } catch (e) {
        console.warn('Initial sign-in attempt failed (will rely on onAuthStateChanged):', e);
      }
    })();

    let currentUser = null;

    async function registerUserStatus(user) {
      try {
        const userDocRef = doc(db, `artifacts/${appId}/public/data/users`, user.uid);
        await setDoc(userDocRef, {
          uid: user.uid,
          email: user.email || 'Anonymous User',
          lastSeen: serverTimestamp()
        }, { merge: true });
      } catch (e) {
        console.error('Failed to register user status:', e);
      }
    }

    function renderChatItem(chat) {
      const other = (chat.participants || []).find(p => p !== currentUser.uid) || chat.participants[0] || 'Unknown';
      const a = document.createElement('a');
      a.className = 'chat-item';
      a.href = `message_view.html?chatId=${encodeURIComponent(chat.chatId)}&recipientUid=${encodeURIComponent(other)}`;
      const avatar = document.createElement('div'); avatar.className = 'chat-avatar'; avatar.textContent = (chat.listingTitle || other).charAt(0).toUpperCase();
      const meta = document.createElement('div');
      const name = document.createElement('div'); name.className = 'chat-name'; name.textContent = chat.listingTitle || other;
      const when = document.createElement('div'); when.className = 'small'; when.textContent = `Updated: ${chat.lastUpdated ? new Date(chat.lastUpdated.seconds*1000).toLocaleString() : 'now'}`;
      meta.appendChild(name); meta.appendChild(when);
      a.appendChild(avatar); a.appendChild(meta);
      return a;
    }

    function setupChatsListener(uid) {
      const chatsRef = collection(db, `artifacts/${appId}/public/data/chats`);
      let unsubscribe = null;
      let triedFallback = false;

      const startListener = (withOrder) => {
        if (unsubscribe) unsubscribe();
        container.innerHTML = '<div class="small">Loading chatsâ€¦</div>';
        let q;
        try {
          if (withOrder) {
            q = query(chatsRef, where('participants', 'array-contains', uid), orderBy('lastUpdated', 'desc'));
          } else {
            q = query(chatsRef, where('participants', 'array-contains', uid));
          }
        } catch (e) {
          console.warn('Query construction failed, falling back to unordered query:', e);
          q = query(chatsRef, where('participants', 'array-contains', uid));
        }

        unsubscribe = onSnapshot(q, (snapshot) => {
          const chats = [];
          snapshot.forEach(docSnap => {
            const data = docSnap.data();
            chats.push(data);
          });

          // If we used unordered query, sort client-side by lastUpdated
          if (!withOrder) {
            chats.sort((a,b)=>{
              const ta = a.lastUpdated && a.lastUpdated.seconds ? a.lastUpdated.seconds : 0;
              const tb = b.lastUpdated && b.lastUpdated.seconds ? b.lastUpdated.seconds : 0;
              return tb - ta; // desc
            });
          }

          // render
          container.innerHTML = '';
          chats.forEach(c => container.appendChild(renderChatItem(c)));

          // If redirected with recipientUid, try to open the chat automatically
          if (initialRecipientUid && !initialRecipientConsumed) {
            const match = chats.find(d => (d.participants || []).includes(initialRecipientUid));
            if (match) {
              initialRecipientConsumed = true;
              const chat = match;
              // forward autoMessage if provided
              const params = new URLSearchParams();
              params.set('chatId', chat.chatId);
              params.set('recipientUid', initialRecipientUid);
              if (initialAutoMessage) params.set('autoMessage', initialAutoMessage);
              window.location.href = `message_view.html?${params.toString()}`;
            }
          }

        }, (err) => {
          console.error('Failed listening to chats (withOrder=' + withOrder + '):', err);
          if (!triedFallback && withOrder) {
            // Try falling back to unordered query and sort client-side
            triedFallback = true;
            console.warn('Falling back to unordered chats listener due to error; this may be caused by missing Firestore index or permissions.');
            startListener(false);
            return;
          }
          container.innerHTML = `<div class="small">Failed to load chats: ${err && err.message ? err.message : 'unknown error'}</div>`;
        });
      };

      // start with ordered listener first (preferred)
      startListener(true);
    }

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUser = user;
        await registerUserStatus(user);
        setupChatsListener(user.uid);
      } else {
        // attempt sign-in
        try {
          const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
          if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
          else await signInAnonymously(auth);
        } catch (e) {
          console.error('Auth failed:', e);
          container.innerHTML = '<div class="small">Authentication failed. Please reload.</div>';
        }
      }
    });
  </script>
</body>
</html>
