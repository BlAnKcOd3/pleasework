<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Chat - De Anza</title>
    <link rel="stylesheet" href="styles.css" />
    <style>
      /* Small chat view styles to complement existing stylesheet */
      .chat-header { background:#4f090c;color:#fff;padding:12px 20px }
      .chat-container { max-width:900px;margin:20px auto;padding-bottom:140px }
      .messages { background:#f6f6f6;padding:16px;border-radius:12px;min-height:300px;display:flex;flex-direction:column;gap:10px;overflow:auto }
      .msg { max-width:70%; padding:10px;border-radius:10px }
      .msg.me { margin-left:auto;background:#4f090c;color:#fff }
      .msg.other { margin-right:auto;background:#fff;color:#111;border:1px solid #e6e6e6 }
      .chat-input { position:fixed;left:0;right:0;bottom:20px;display:flex;justify-content:center }
      .chat-input .bar { max-width:900px;width:100%;display:flex;gap:8px;padding:10px }
      .chat-input input { flex:1;padding:10px;border-radius:8px;border:1px solid #ccc }
      .chat-input button { padding:10px 16px;border-radius:8px;background:#4f090c;color:#fff;border:none }
    </style>
  </head>
  <body>
    <header class="chat-header"><h1 id="chatTitle">Chat</h1></header>

    <main class="chat-container">
      <div id="status" style="text-align:center;margin-bottom:8px;color:#444;font-size:0.95em"></div>
      <div id="messages" class="messages"><div class="small">Loading messagesâ€¦</div></div>
    </main>

    <div class="chat-input">
      <div class="bar">
        <input id="messageInput" placeholder="Type a message..." aria-label="Type a message" />
        <button id="sendBtn">Send</button>
      </div>
    </div>

    <footer class="site-footer">
      <a href="index.html"><img src="https://i.ibb.co/wNYjZG9k/Image-11-21-25-at-2-05-PM.png" alt="logo"></a>
    </footer>

    <script src="firebase_config.js"></script>

    <script type="module">
      // Real-time messaging using Firestore
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        collection,
        query,
        orderBy,
        onSnapshot,
        addDoc,
        serverTimestamp,
        doc,
        setDoc,
        getDoc
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      const params = new URLSearchParams(window.location.search);
      const qChatId = params.get('chatId');
      const qRecipient = params.get('recipientUid');
      const qListingId = params.get('listingId');
      const qAutoMessage = params.get('autoMessage');
      const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

      const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}') || {
        apiKey: "AIzaSyBJJYUOM8EBEuT39DX2F_HtxgEbHDRH-Zc",
        authDomain: "deanzahacks11-21-2025.firebaseapp.com",
        projectId: "deanzahacks11-21-2025"
      };

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      // Try sign-in proactively so the auth listener has work to do immediately
      (async function trySignIn() {
        try {
          const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
          if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
          else await signInAnonymously(auth);
        } catch (e) {
          console.warn('Proactive sign-in failed:', e);
        }
      })();

      const statusEl = document.getElementById('status');
      const messagesEl = document.getElementById('messages');
      // Local relay toggle will be inserted below status
      // create a placeholder; we'll wire this up after DOM selection
      const localToggleContainer = document.createElement('div');
      localToggleContainer.style.textAlign = 'center';
      localToggleContainer.style.marginBottom = '8px';
      localToggleContainer.innerHTML = '<label style="font-size:0.9em;color:#444"><input type="checkbox" id="localToggle" style="margin-right:6px">Use Local Relay</label>';
      statusEl.insertAdjacentElement('afterend', localToggleContainer);
      const localToggleEl = document.getElementById('localToggle');
      const inputEl = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const chatTitle = document.getElementById('chatTitle');

      let currentUser = null;
      let messagesUnsub = null;
      let currentChatId = qChatId || null;
      let recipientUid = qRecipient || null;
      let isChatReady = false;
      let useLocalWs = false;
      let ws = null;

      // disable input until auth+chat ready
      inputEl.disabled = true;
      sendBtn.disabled = true;

      function getChatId(a,b){
        const sorted = [String(a), String(b)].sort();
        return sorted.join('_');
      }

      function formatTime(ts){
        try{
          const d = ts && ts.toDate ? ts.toDate() : (ts ? new Date(ts) : new Date());
          return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }catch(e){ return '' }
      }

      function setStatus(text){
        if(statusEl) statusEl.textContent = text || '';
      }

      function appendMessage(docData){
        const wrapper = document.createElement('div');
        wrapper.className = docData.senderId === currentUser.uid ? 'msg me' : 'msg other';

        const meta = document.createElement('div');
        meta.style.fontSize = '0.75em';
        meta.style.opacity = '0.9';
        meta.style.marginBottom = '6px';
        meta.textContent = docData.senderId === currentUser.uid ? 'You' : (docData.senderEmail || 'Seller');

        const text = document.createElement('div');
        text.textContent = docData.text || '';

        const time = document.createElement('div');
        time.style.fontSize = '0.7em';
        time.style.opacity = '0.7';
        time.style.marginTop = '6px';
        time.textContent = formatTime(docData.timestamp);

        wrapper.appendChild(meta);
        wrapper.appendChild(text);
        wrapper.appendChild(time);

        messagesEl.appendChild(wrapper);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      async function ensureChatMetadata(chatId){
        try{
          const chatDocRef = doc(db, `artifacts/${appId}/public/data/chats`, chatId);
          await setDoc(chatDocRef, {
            chatId: chatId,
            participants: [currentUser.uid, recipientUid].sort(),
            listingId: qListingId || null,
            lastUpdated: serverTimestamp()
          }, { merge: true });
        }catch(e){ console.error('ensureChatMetadata error', e); }
      }

      function listenToMessages(chatId){
        if(messagesUnsub) messagesUnsub();
        messagesEl.innerHTML = '<div class="small">Loading messages...</div>';
        setStatus('Connecting to chat...');
        const messagesRef = collection(db, `artifacts/${appId}/public/data/chats/${chatId}/messages`);
        const q = query(messagesRef, orderBy('timestamp', 'asc'));
        try{
            messagesUnsub = onSnapshot(q, (snapshot)=>{
              setStatus('');
              isChatReady = true;
              inputEl.disabled = false;
              sendBtn.disabled = false;
              // if WS was active, keep it but still show Firestore-sourced messages
              if(!snapshot || snapshot.empty){ messagesEl.innerHTML = '<div class="small">No messages yet. Say hi!</div>'; return; }
              messagesEl.innerHTML = '';
              snapshot.forEach(docSnap => {
                appendMessage(docSnap.data());
              });
            }, (err)=>{
              console.error('message listener error', err);
              // If the listener fails, fall back to the local WebSocket relay when requested
              isChatReady = true; // allow sending even if listener fails
              inputEl.disabled = false;
              sendBtn.disabled = false;
              setStatus('Real-time listener error: ' + (err && err.message ? err.message : 'unknown'));
              messagesEl.innerHTML = '<div class="small">Could not load messages in real-time. Switching to local relay if available.</div>';
              // Start WS fallback automatically, or if the user toggled local relay
              if(params.get('local') === '1' || (localToggleEl && localToggleEl.checked)){
                useLocalWs = true;
                initializeWs(chatId);
              } else {
                // If the user hasn't toggled local yet, enable the toggle so they can
                if(localToggleEl) localToggleEl.checked = false;
              }
            });
        }catch(e){
          console.error('listenToMessages failed to attach listener', e);
          setStatus('Could not attach message listener: ' + (e && e.message));
          messagesEl.innerHTML = '<div class="small">Message listener unavailable. Switching to local relay if available.</div>';
          // Auto-start WS if requested by URL param or toggle
          if(params.get('local') === '1' || (localToggleEl && localToggleEl.checked)){
            useLocalWs = true;
            initializeWs(chatId);
          }
        }
      }

      // WebSocket fallback (local testing): connects to ws://localhost:3000
      function initializeWs(chatId){
        try{
          if(ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
          setStatus('Connecting to local relay...');
          ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.hostname + ':3000');
          ws.addEventListener('open', ()=>{
            setStatus('Connected to local relay');
            try{ ws.send(JSON.stringify({ type: 'join', chatId })); }catch(e){}
            // request history (server may send recent messages)
          });
          ws.addEventListener('message', (ev)=>{
            try{
              const data = JSON.parse(ev.data);
              if(data && data.type === 'history' && Array.isArray(data.messages)){
                messagesEl.innerHTML = '';
                data.messages.forEach(m => appendMessage(m));
              }else if(data && data.type === 'message'){
                appendMessage(data.message);
              }
            }catch(e){ console.warn('ws message parse failed', e); }
          });
          ws.addEventListener('close', ()=>{ setStatus('Local relay disconnected'); });
          ws.addEventListener('error', (e)=>{ console.warn('ws error', e); setStatus('Local relay error'); });
        }catch(e){ console.warn('initializeWs failed', e); setStatus('Local relay unavailable'); }
      }

      async function sendMessage(){
        const text = inputEl.value.trim();
        if(!text) return;
        if(!currentChatId || !recipientUid){ alert('Chat not initialized.'); return; }
        // optimistic UI append (use current time locally)
        appendMessage({ text, senderId: currentUser.uid, senderEmail: currentUser.email || 'You', timestamp: new Date() });
        inputEl.value = '';
        try{
          if(useLocalWs && ws && ws.readyState === WebSocket.OPEN){
            // send via local WS relay
            ws.send(JSON.stringify({ type: 'message', chatId: currentChatId, message: {
              text: text,
              timestamp: new Date().toISOString(),
              senderId: currentUser.uid,
              senderEmail: currentUser.email || null,
              recipientId: recipientUid
            }}));
          }else{
            const messagesRef = collection(db, `artifacts/${appId}/public/data/chats/${currentChatId}/messages`);
            await addDoc(messagesRef, {
              text: text,
              timestamp: serverTimestamp(),
              senderId: currentUser.uid,
              senderEmail: currentUser.email || null,
              recipientId: recipientUid
            });
            // bump chat metadata
            const chatDocRef = doc(db, `artifacts/${appId}/public/data/chats`, currentChatId);
            await setDoc(chatDocRef, { lastUpdated: serverTimestamp() }, { merge: true });
          }
        }catch(e){
          console.error('sendMessage error', e);
          setStatus('Failed to send message: ' + (e && e.message));
        }
      }

      sendBtn.addEventListener('click', ()=>{ if(isChatReady) sendMessage(); else alert('Chat not ready yet.'); });
      inputEl.addEventListener('keypress', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); if(isChatReady) sendMessage(); else alert('Chat not ready yet.'); } });

      // Try to fetch recipient user info for display
      async function fetchRecipientName(uid){
        try{
          const uDoc = await getDoc(doc(db, `artifacts/${appId}/public/data/users`, uid));
          if(uDoc && uDoc.exists()){
            return uDoc.data().email || uid;
          }
        }catch(e){ console.warn('fetchRecipientName failed', e); }
        return uid;
      }

      // Register current user presence
      async function registerPresence(user){
        try{
          await setDoc(doc(db, `artifacts/${appId}/public/data/users`, user.uid), {
            uid: user.uid,
            email: user.email || 'Anonymous User',
            lastSeen: serverTimestamp()
          }, { merge: true });
        }catch(e){ console.error('registerPresence error', e); }
      }

      // Auth flow
      onAuthStateChanged(auth, async (user)=>{
        if(user){
          currentUser = user;
          await registerPresence(user);
          // Determine chat id if missing
          if(!currentChatId){
            if(!recipientUid){
              // nothing to chat with
              chatTitle.textContent = 'Chat';
              messagesEl.innerHTML = '<div class="small">No recipient specified.</div>';
              return;
            }
            currentChatId = getChatId(currentUser.uid, recipientUid);
          }
          // ensure chat metadata exists
          await ensureChatMetadata(currentChatId);
          // set title
          if(recipientUid){
            const name = await fetchRecipientName(recipientUid);
            chatTitle.textContent = `Chat with ${name}`;
          }
          // start listening
          listenToMessages(currentChatId);
          // If an auto-message was provided (from listings), send it once
          if (qAutoMessage && qAutoMessage.trim().length > 0) {
            // send automatically but only once
            const msg = qAutoMessage;
            // clear param so we don't resend if auth state changes
            try{ params.delete('autoMessage'); }catch(e){}
            // small timeout to ensure listener is active
            setTimeout(async ()=>{
              try{
                const messagesRef = collection(db, `artifacts/${appId}/public/data/chats/${currentChatId}/messages`);
                await addDoc(messagesRef, {
                  text: msg,
                  timestamp: serverTimestamp(),
                  senderId: currentUser.uid,
                  senderEmail: currentUser.email || null,
                  recipientId: recipientUid
                });
                // bump chat metadata
                const chatDocRef = doc(db, `artifacts/${appId}/public/data/chats`, currentChatId);
                await setDoc(chatDocRef, { lastUpdated: serverTimestamp() }, { merge: true });
                inputEl.value = '';
              }catch(e){ console.error('auto send failed', e); }
            }, 250);
          }
        }else{
          // try sign-in
          try{
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            if(initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
            else await signInAnonymously(auth);
          }catch(e){ console.error('auth failed', e); messagesEl.innerHTML = '<div class="small">Authentication failed.</div>'; }
        }
      });
    </script>
  </body>
</html>
